# yaml-language-server: $schema=https://raw.githubusercontent.com/typeddjango/pytest-mypy-plugins/master/pytest_mypy_plugins/schema.json

# =============================================================================
# Basic: typo, wrong type, valid replace
# =============================================================================

- case: typo_field_name_caught
  mypy_config: &mypy_config |
    [mypy]
    plugins = plugins.pydantic_replace
    python_version = 3.13
    strict = true
    [pydantic-mypy]
    init_forbid_extra = true
    init_typed = true
  main: |
    from pydantic import BaseModel, ConfigDict

    class Metric(BaseModel):
        model_config = ConfigDict(frozen=True)
        name: str
        value: float

    m = Metric(name="test", value=1.0)
    m.__replace__(naem="oops")  # E: Unexpected keyword argument "naem" for "__replace__" of "Metric"  [call-arg]

- case: wrong_type_caught
  mypy_config: *mypy_config
  main: |
    from pydantic import BaseModel, ConfigDict

    class Metric(BaseModel):
        model_config = ConfigDict(frozen=True)
        name: str
        value: float

    m = Metric(name="test", value=1.0)
    m.__replace__(value="not_a_float")  # E: Argument "value" to "__replace__" of "Metric" has incompatible type "str"; expected "float"  [arg-type]

- case: valid_replace_passes
  mypy_config: *mypy_config
  main: |
    from pydantic import BaseModel, ConfigDict

    class Metric(BaseModel):
        model_config = ConfigDict(frozen=True)
        name: str
        value: float

    m = Metric(name="test", value=1.0)
    m2 = m.__replace__(name="updated", value=2.0)

- case: all_args_optional
  mypy_config: *mypy_config
  main: |
    from pydantic import BaseModel, ConfigDict

    class Metric(BaseModel):
        model_config = ConfigDict(frozen=True)
        name: str
        value: float

    m = Metric(name="test", value=1.0)
    m2 = m.__replace__()  # No args â€” all optional

- case: return_type_is_model
  mypy_config: *mypy_config
  main: |
    from pydantic import BaseModel, ConfigDict

    class Metric(BaseModel):
        model_config = ConfigDict(frozen=True)
        name: str
        value: float

    m = Metric(name="test", value=1.0)
    reveal_type(m.__replace__(name="x"))  # N: Revealed type is "main.Metric"

- case: multiple_fields_at_once
  mypy_config: *mypy_config
  main: |
    from pydantic import BaseModel, ConfigDict

    class Metric(BaseModel):
        model_config = ConfigDict(frozen=True)
        name: str
        value: float
        unit: str

    m = Metric(name="test", value=1.0, unit="ms")
    m2 = m.__replace__(name="updated", value=2.0, unit="s")

# =============================================================================
# Inheritance: narrowed fields, LSP compliance
# =============================================================================

- case: narrowed_field_no_lsp_error
  mypy_config: *mypy_config
  main: |
    from typing import Literal
    from pydantic import BaseModel, ConfigDict

    class WebVitalMetric(BaseModel):
        model_config = ConfigDict(frozen=True)
        name: str
        value: float

    class LCPMetric(WebVitalMetric):
        name: Literal['LCP'] = 'LCP'
        size: int | None = None

    # __replace__ uses parent's str type for name, not Literal['LCP']
    m = LCPMetric(name='LCP', value=1.0)
    m2 = m.__replace__(name='LCP')  # Should accept str, not just Literal

- case: child_adds_fields
  mypy_config: *mypy_config
  main: |
    from typing import Literal
    from pydantic import BaseModel, ConfigDict

    class WebVitalMetric(BaseModel):
        model_config = ConfigDict(frozen=True)
        name: str
        value: float

    class LCPMetric(WebVitalMetric):
        name: Literal['LCP'] = 'LCP'
        size: int | None = None
        url: str | None = None

    m = LCPMetric(name='LCP', value=1.0)
    m.__replace__(size=100, url="https://example.com")

- case: child_inherits_parent_fields
  mypy_config: *mypy_config
  main: |
    from typing import Literal
    from pydantic import BaseModel, ConfigDict

    class WebVitalMetric(BaseModel):
        model_config = ConfigDict(frozen=True)
        name: str
        value: float

    class LCPMetric(WebVitalMetric):
        name: Literal['LCP'] = 'LCP'

    m = LCPMetric(name='LCP', value=1.0)
    m.__replace__(value=2.0)  # Parent field accessible

- case: return_type_is_child_not_parent
  mypy_config: *mypy_config
  main: |
    from typing import Literal
    from pydantic import BaseModel, ConfigDict

    class WebVitalMetric(BaseModel):
        model_config = ConfigDict(frozen=True)
        name: str
        value: float

    class LCPMetric(WebVitalMetric):
        name: Literal['LCP'] = 'LCP'

    m = LCPMetric(name='LCP', value=1.0)
    reveal_type(m.__replace__(value=2.0))  # N: Revealed type is "main.LCPMetric"

- case: generic_parent_type_expansion
  mypy_config: *mypy_config
  main: |
    from typing import Generic, TypeVar
    from pydantic import BaseModel, ConfigDict

    T = TypeVar('T')

    class Response(BaseModel, Generic[T]):
        model_config = ConfigDict(frozen=True)
        data: T
        status: int

    class StringResponse(Response[str]):
        pass

    r = StringResponse(data="hello", status=200)
    r.__replace__(data="world")
    r.__replace__(data=123)  # E: Argument "data" to "__replace__" of "StringResponse" has incompatible type "int"; expected "str"  [arg-type]
    reveal_type(r.__replace__())  # N: Revealed type is "main.StringResponse"

- case: pure_inheritance_no_new_fields
  mypy_config: *mypy_config
  main: |
    from pydantic import BaseModel, ConfigDict

    class Parent(BaseModel):
        model_config = ConfigDict(frozen=True)
        name: str
        value: float

    class Child(Parent):
        pass

    m = Child(name="test", value=1.0)
    m.__replace__(name="updated")
    reveal_type(m.__replace__())  # N: Revealed type is "main.Child"

- case: three_level_inheritance_uses_widest_type
  mypy_config: *mypy_config
  main: |
    from typing import Literal
    from pydantic import BaseModel, ConfigDict

    class Base(BaseModel):
        model_config = ConfigDict(frozen=True)
        name: str
        value: float

    class Middle(Base):
        name: Literal['metric', 'LCP'] = 'metric'

    class Leaf(Middle):
        name: Literal['LCP'] = 'LCP'
        extra: int = 0

    m = Leaf(value=1.0)
    # name should accept str (Base's type), not Literal['metric', 'LCP'] or Literal['LCP']
    m.__replace__(name='anything', value=2.0, extra=5)
    reveal_type(m.__replace__())  # N: Revealed type is "main.Leaf"

# =============================================================================
# Guards: user-defined __replace__, Python < 3.13, no fields
# =============================================================================

- case: user_defined_replace_preserved
  mypy_config: *mypy_config
  main: |
    from typing import Self
    from pydantic import BaseModel, ConfigDict

    class CustomModel(BaseModel):
        model_config = ConfigDict(frozen=True)
        name: str

        def __replace__(self, **kwargs: str) -> Self:
            return self.model_copy(update=kwargs)

    m = CustomModel(name="test")
    reveal_type(m.__replace__)  # N: Revealed type is "def (**kwargs: builtins.str) -> main.CustomModel"

- case: python_312_no_synthesis
  # disable_cache required: pytest-mypy-plugins cleans cache using host Python
  # version (3.13), missing files cached under target version (3.12).
  disable_cache: true
  mypy_config: |
    [mypy]
    plugins = plugins.pydantic_replace
    python_version = 3.12
    [pydantic-mypy]
    init_forbid_extra = true
    init_typed = true
  main: |
    from pydantic import BaseModel, ConfigDict

    class Metric(BaseModel):
        model_config = ConfigDict(frozen=True)
        name: str

    m = Metric(name="test")
    m.__replace__(name="x")  # E: "Metric" has no attribute "__replace__"  [attr-defined]

- case: empty_model_no_synthesis
  mypy_config: *mypy_config
  main: |
    from pydantic import BaseModel, ConfigDict

    class Empty(BaseModel):
        model_config = ConfigDict(frozen=True)

    m = Empty()
    m.__replace__()  # E: "Empty" has no attribute "__replace__"  [attr-defined]

# =============================================================================
# Alias compatibility
# =============================================================================

- case: alias_model_replace_uses_python_names
  mypy_config: *mypy_config
  main: |
    from typing import Literal
    from pydantic import BaseModel, ConfigDict, Field

    class Decision(BaseModel):
        model_config = ConfigDict(frozen=True, populate_by_name=True)
        permission_decision: Literal['allow', 'deny'] = Field(alias='permissionDecision')
        reason: str | None = Field(default=None, alias='permissionDecisionReason')

    d = Decision(permission_decision='allow')
    # __replace__ uses Python names, not aliases
    d.__replace__(permission_decision='deny')
    d.__replace__(reason="updated")

- case: alias_rejected_in_replace
  mypy_config: *mypy_config
  main: |
    from typing import Literal
    from pydantic import BaseModel, ConfigDict, Field

    class Decision(BaseModel):
        model_config = ConfigDict(frozen=True, populate_by_name=True)
        permission_decision: Literal['allow', 'deny'] = Field(alias='permissionDecision')

    d = Decision(permission_decision='allow')
    d.__replace__(permissionDecision='deny')  # E: Unexpected keyword argument "permissionDecision" for "__replace__" of "Decision"; did you mean "permission_decision"?  [call-arg]

- case: alias_generator_replace_uses_python_names
  mypy_config: *mypy_config
  main: |
    from pydantic import BaseModel, ConfigDict
    from pydantic.alias_generators import to_camel

    class Config(BaseModel):
        model_config = ConfigDict(frozen=True, alias_generator=to_camel, populate_by_name=True)
        file_path: str
        line_number: int

    c = Config(file_path="/tmp/test", line_number=42)
    # __replace__ uses Python snake_case names
    c.__replace__(file_path="/tmp/updated", line_number=100)

# =============================================================================
# Real-world: IndexingResult pattern from document-search
# =============================================================================

- case: indexing_result_timing_replace
  mypy_config: *mypy_config
  main: |
    from pydantic import BaseModel, ConfigDict

    class TimingReport(BaseModel):
        model_config = ConfigDict(frozen=True)
        scan_ms: float
        embed_ms: float

    class IndexingResult(BaseModel):
        model_config = ConfigDict(frozen=True)
        chunks_created: int
        elapsed_seconds: float
        timing: TimingReport | None = None

    result = IndexingResult(chunks_created=10, elapsed_seconds=1.5, timing=None)

    # Valid: set timing to None (the actual pattern in server.py)
    result2 = result.__replace__(timing=None)

    # Invalid: wrong type for timing
    result.__replace__(timing="bad")  # E: Argument "timing" to "__replace__" of "IndexingResult" has incompatible type "str"; expected "TimingReport | None"  [arg-type]

    # Invalid: typo
    result.__replace__(timming=None)  # E: Unexpected keyword argument "timming" for "__replace__" of "IndexingResult"; did you mean "timing"?  [call-arg]

# =============================================================================
# Edge cases
# =============================================================================

- case: optional_field_accepts_none
  mypy_config: *mypy_config
  main: |
    from pydantic import BaseModel, ConfigDict

    class Model(BaseModel):
        model_config = ConfigDict(frozen=True)
        name: str
        optional_field: int | None = None

    m = Model(name="test", optional_field=5)
    m.__replace__(optional_field=None)

- case: required_field_still_optional_in_replace
  mypy_config: *mypy_config
  main: |
    from pydantic import BaseModel, ConfigDict

    class Model(BaseModel):
        model_config = ConfigDict(frozen=True)
        required_field: str  # No default

    m = Model(required_field="value")
    # All __replace__ args are optional even if field has no default
    m2 = m.__replace__()

- case: mutable_model_has_replace
  mypy_config: *mypy_config
  main: |
    from pydantic import BaseModel

    class Mutable(BaseModel):
        name: str
        value: float

    m = Mutable(name="test", value=1.0)
    # Works on both mutable and frozen models
    m.__replace__(name="updated")

- case: intermediate_base_class_config
  mypy_config: *mypy_config
  main: |
    from pydantic import BaseModel, ConfigDict

    class StrictModel(BaseModel):
        model_config = ConfigDict(extra='forbid', strict=True, frozen=True)

    class Metric(StrictModel):
        name: str
        value: float

    m = Metric(name="test", value=1.0)
    m.__replace__(name="updated")
    m.__replace__(bad_field=1)  # E: Unexpected keyword argument "bad_field" for "__replace__" of "Metric"  [call-arg]

- case: copy_replace_integration
  mypy_config: *mypy_config
  main: |
    import copy
    from pydantic import BaseModel, ConfigDict

    class Metric(BaseModel):
        model_config = ConfigDict(frozen=True)
        name: str
        value: float

    m = Metric(name="test", value=1.0)
    m2 = copy.replace(m, name="updated")
    reveal_type(m2)  # N: Revealed type is "main.Metric"
